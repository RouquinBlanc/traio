"""
Test nested Nurseries
"""
import asyncio
import time

import pytest

from tests import run10
from traio import Scope


@pytest.mark.asyncio
async def test_nested_unrelated():
    """
    Two nested Nurseries, outer will timeout before inner.
    This should be handled properly now.
    """
    before = time.time()

    with pytest.raises(TimeoutError):
        async with Scope(timeout=0.2):
            async with Scope(timeout=0.5) as inner:
                """
                A completely different
                """
                inner.spawn(run10())

    after = time.time()
    assert (after - before) < 0.4, 'for now...'


@pytest.mark.asyncio
async def test_nested_fork_timeout_parent():
    """
    Two nested Nurseries, inner one generated by parent
    """
    before = time.time()

    with pytest.raises(TimeoutError):
        async with Scope(timeout=0.1) as parent:
            async with parent.fork() as inner:
                inner.spawn(run10())

    after = time.time()
    assert (after - before) < 0.2


@pytest.mark.asyncio
async def test_nested_fork_timeout_parent_no_env():
    """
    Two nested Nurseries, inner one generated by parent
    """
    before = time.time()

    with pytest.raises(TimeoutError):
        async with Scope(timeout=0.1) as parent:
            inner = parent.fork()
            inner.spawn(run10())
            await inner

    after = time.time()
    assert (after - before) < 0.2


@pytest.mark.asyncio
async def test_nested_fork_timeout_inner():
    """
    Two nested Nurseries, but completely unrelated.
    Remember that we cannot do magic (yet).
    As long as the inner code is blocking and
    not related to the surrounding Scope,
    The outer timeout will be stuck!
    """
    before = time.time()

    with pytest.raises(TimeoutError):
        async with Scope() as parent:
            parent.spawn(run10())
            async with parent.fork(timeout=0.1) as inner:
                inner.spawn(run10())

    after = time.time()
    assert (after - before) < 0.2


@pytest.mark.asyncio
async def test_fork_dead():
    """
    Try to fork a dead scope.
    """
    scope = Scope()

    async with scope:
        pass

    with pytest.raises(AssertionError):
        _ = scope.fork()


@pytest.mark.asyncio
async def test_nested_fork_timeout_sibling():
    """
    Two nested Nurseries, but completely unrelated.
    Remember that we cannot do magic (yet).
    As long as the inner code is blocking and
    not related to the surrounding Scope,
    The outer timeout will be stuck!
    """
    before = time.time()

    async def fork_my_parent(scope, timeout: float = 0):
        async with scope.fork(timeout=timeout) as inner:
            inner.spawn(run10())

    with pytest.raises(TimeoutError):
        async with Scope() as parent:
            parent.spawn(run10())

            # First long one
            parent.spawn(fork_my_parent(parent))

            # Second will timeout soon
            parent.spawn(fork_my_parent(parent, timeout=0.1))

    after = time.time()
    assert (after - before) < 0.2


@pytest.mark.asyncio
async def test_nested_fork_raises_catch():
    """
    Two nested Nurseries, but completely unrelated.
    Remember that we cannot do magic (yet).
    As long as the inner code is blocking and
    not related to the surrounding Scope,
    The outer timeout will be stuck!
    """
    before = time.time()

    async def bomb():
        await asyncio.sleep(0.2)
        raise ValueError('boom!')

    with pytest.raises(TimeoutError):
        async with Scope(timeout=0.5) as parent:
            parent.spawn(run10(), name='run10')

            inner = parent.fork()
            inner.spawn(bomb())

            with pytest.raises(ValueError):
                # This should prevent bubbling
                await inner

    after = time.time()
    assert (after - before) > 0.4


@pytest.mark.parametrize('wait', [True, False])
@pytest.mark.asyncio
async def test_nested_cancel_join(wait):
    """
    """
    parent = Scope()

    child = parent.fork()
    child << run10()

    await asyncio.sleep(0.1)

    child.cancel()
    parent.cancel()

    if wait:
        await parent
    else:
        await asyncio.wait_for(parent, 1)


@pytest.mark.asyncio
async def test_nested_cancel_wait():
    """
    """
    parent = Scope()

    child = parent.fork()
    child << run10()

    await asyncio.sleep(0.1)

    child.cancel()
    parent.cancel()

    await asyncio.wait_for(asyncio.shield(parent), 1)


@pytest.mark.asyncio
async def test_context():
    """
    Check Scope.get_current() in different situations
    """
    assert Scope.get_current() is None

    # Create a first Scope
    n = Scope()

    n2 = Scope()

    Scope._set_current(n2)
    assert Scope.get_current() == n2

    async def sub():
        old = Scope.get_current()
        assert old == n

        async with old.fork() as new:
            assert Scope.get_current() == new

            async def test_old():
                assert Scope.get_current() == old

            async def test_new():
                assert Scope.get_current() == new

            await test_new()
            await asyncio.ensure_future(test_new())
            new << test_new()

            old << test_old()

    async with n:
        assert Scope.get_current() == n

        n << sub()

    assert Scope.get_current() == n2

    Scope._set_current(None)
    assert Scope.get_current() is None